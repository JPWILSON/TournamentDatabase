-- Table definitions for the tournament project.
--
-- Put your SQL 'create table' statements in this file; also 'create view'
-- statements if you choose to use it.
--
-- You can write comments in this file by starting them with two dashes, like
-- these lines here.

-- The seven lines of code below are for ease of testing, but can be commented out once 
--      testing is concluded. They delete and recreate and connect to the 
--      database and tables.
DROP DATABASE tournament;
CREATE DATABASE tournament;
\c tournament;
DROP TABLE tournament_players; -- Not necessary if database dropped.
DROP TABLE matches;			   -- Not necessary if database dropped.
DROP TABLE tournaments;		   -- Not necessary if database dropped.
DROP TABLE players;			   -- Not necessary if database dropped.

--This is the actual start of the database schema

CREATE TABLE players(
	id serial PRIMARY KEY,
	name text
);

CREATE TABLE tournaments(
	id serial PRIMARY KEY,
	name text,
	winner_id integer REFERENCES players(id)
);

-- Below, player1_result and player2_result are given values of 2(win), 1(draw), 0(loss)
CREATE TABLE matches(
	tournament_id integer REFERENCES tournaments(id),
	player1_id integer REFERENCES players(id),
	player2_id integer REFERENCES players(id),
	player1_result integer,
	player2_result integer,
	PRIMARY KEY(tournament_id, player1_id, player2_id)
);

CREATE TABLE tournament_players(
	tournament_id integer REFERENCES tournaments(id),
	player_id integer REFERENCES players(id),
	PRIMARY KEY (tournament_id, player_id)
);

--NOTE: Views are denoted by 'v_' precedding their name.
--Concatenating the results from players 1 and 2 into a view:
CREATE OR REPLACE VIEW v_p1p2_combined AS
SELECT player1_id AS id, 
SUM(player1_result) AS wins,
COUNT(player1_result) AS matches
FROM matches
GROUP BY id
UNION
SELECT player2_id AS id, 
SUM(player2_result) AS wins,
COUNT(player2_result) AS matches
FROM matches
GROUP BY id;


-- Note: The player standings view is generated by 
--    combining the results (v_p1p2_combined) with the players table
--    to obtain the id and name of each plyaer along with their win
--    and matches record.

CREATE OR REPLACE VIEW v_standings AS
SELECT players.id,
players.name,
SUM(v_p1p2_combined.wins) AS win,
COUNT(v_p1p2_combined.matches) AS match
FROM players FULL OUTER JOIN v_p1p2_combined
ON players.id = v_p1p2_combined.id
GROUP BY players.id
ORDER BY win DESC;


/*
Note: usually, the player standings would be calculated by 
combining the results (v_p1p2_combined) with the players table as shown above. However, 
the players table may have players from another tournament. Therefore, to get the 
standings, the players are selected from the tournament_players table, for each tournament
and then in tournament.py, playerStandings_tourney specifies the tournament. This is commented out for ease of testing, but is shown here:

CREATE OR REPLACE VIEW v_standings AS
	SELECT 
		(SELECT players.id, players.name, tournament_players.tournament_id 
			FROM players JOIN tournament_players
			ON players.id = tournament_players.tournament_id),
		SUM(v_p1p2_combined.wins) AS win,
		COUNT(v_p1p2_combined.matches) AS match
		FROM players FULL OUTER JOIN v_p1p2_combined
		ON players.id = v_p1p2_combined.id
		GROUP BY players.id
		ORDER BY win DESC;
*/


-- Lastly, to satisfy the test in tournament_test.py for playerStandings, newly 
--    entered players require '0' as their match and wins result, and that is 
-- 	  why the case statements below are required, to prevent a null value 
-- 	  from causing the tests made by udacity in tournament_test.py to fail. 

-- Put differently, the final standings table is v_r_standings, below (v - view, r - real)
CREATE OR REPLACE VIEW v_r_standings AS
SELECT *,
CASE WHEN match = 0 THEN NULL ELSE match END AS matches,
CASE WHEN win IS NULL THEN 0 ELSE win END AS wins
FROM v_standings;
